# 만들면서 배우는 클린 아키텍처

### 1장. 계층형 아키텍처의 문제는 무엇일까?

일반적인 3계층 아키텍처는 **웹 -> 도메인 -> 영속성** 으로 구성되어 있다.  
웹 계층에서 요청을 받아 도메인 혹은 비즈니스 계층에 있는 서비스로 요청을 보낸다. 서비스에서는 필요한 비즈니스 로직을 수행하고, 도메인 엔티티의 현재 상태를 조회하거나 변경하기 위해 **영속성** 계층의 컴포넌트를 호출한다.  
잘 만들어진 계층형 아키텍처는 선택의 폭을 넓히고 변화하는 요구사항과 외부 요인에 빠르게 적응할 수 있게 해준다. 하지만 코드에 나쁜 습관들이 스며들기 쉽게 만들고 시간이 지날수록 소프트웨어를 점점 더 변경하기 어렵게 만드는 수많은 허점들을 노출한다. 그 이유는 다음과 같다.

1. 계층형 아키텍처는 데이터베이스 주도 설계를 유도한다.
2. 지름길을 택하기 쉬워진다.
3. 테스트하기 어려워진다.
4. 유스케이스를 숨긴다.
5. 동시 작업이 어려워진다.

앞서 말한 이유들로 인해 계층형 아키텍처는 개발자로 하여금 시간이 지날수록 유지보수하기 어렵게 만든다.



### 2장. 의존성 역전하기

> 단일 책임 원칙(Single Responsibility Principle, SRP)  
> 컴포넌트를 변경하는 이유는 오직 하나뿐이어야 한다.

만약 컴포넌트를 변경할 이유가 한 가지라면 우리가 어떤 다른 이유로 소프트웨어를 변경하더라도 이 컴포넌트에 대해서는 전혀 신경 쓸 필요가 없다. 소프트웨어가 변경되더라도 여전히 우리가 기대한 대로 동작할 것이기 때문이다.  
하지만 많은 코드는 SRP를 위반하기 때문에 시간이 갈수록 변경하기가 더 어려워지고 그로 인해 변경 비용도 증가한다. 시간이 갈수록 컴포넌트가 변경할 더 많은 이유가 쌓여간다. 이후에는 한 컴포넌트를 바꾸는 것이 다른 컴포넌트가 실패하는 원인으로 작용할 수 있다.

계층형 아키텍처에서 계층 간 의존성은 항상 아래 방향(계층)을 가리킨다. 그러므로 영속성 계층에 대한 도메인 계층의 의존성 때문에 영속성 계층을 변경할 때마다 잠재적으로 도메인 계층도 변경해야 한다. 그러나 도메인 코드는 애플리케이션에서 가장 핵심 부분이기 때문에 영속성 코드가 바뀐다고 해서 도메인 코드까지 바꾸는 건 바람직하지 않다. 이 의존성을 제거하기 위해 **의존성 역전 원칙**을 이용해보자.

> 의존성 역전 원칙(Dependency Inversion Principle, DIP)  
> 코드상의 어떤 의존성이든 그 방향을 바꿀 수(역전시킬 수) 있다.

참고로 의존성의 양쪽 코드를 모두 제어할 수 있을 때만 의존성을 역전시킬 수 있다.
도메인 코드와 영속성 코드 간의 의존성을 역전시켜서 영속성 코드가 도메인 코드에 의존하고, 도메인 코드를 '변경할 이유'의 개수를 줄여보자.

![그림1.2](/pic/그림1.2.png)

엔티티는 도메인 객체를 표현하고 도메인 코드는 이 엔티티들의 상태를 변경하는 일을 중심으로 하기 때문에 먼저 엔티티를 도메인 계층으로 올린다.

이제 영속성 계층의 리포지토리가 도메인 계층에 있는 엔티티에 의존하기 때문에 두 계층 사이에 순환 의존성이 생긴다. 이제 DIP 를 적용할 수 있다. 도메인 계층에 리포지토리에 대한 인터페이스를 만들고, 실제 리포지토리는 영속성 계층에서 구현하게 하는 것이다. 결과는 다음 그림과 같다.

![그림2.2](/pic/그림2.2.png)

이처럼 도메인 계층에 인터페이스를 도입함으로써 의존성을 역전시킬 수 있고, 그 덕분에 영속성 계층이 도메인 계층에 의존하게 되었다. 이것이 바로 다음에 살펴볼 두 가지 아키텍처 스타일의 핵심 기능이다.

> 클린 아키텍처  
설계가 비즈니스 규칙의 테스트를 용이하게 하고, 비즈니스 규칙은 프레임워크, 데이터베이스, UI 기술, 그 밖의 외부 애플리케이션이나 인터페이스로부터 독립적일 수 있다.

![그림2.3](/pic/그림2.3.png)

- 엔티티(Entities)
    - 핵심 업무 규칙을 캡슐화한다.
    - 메서드를 가지는 객체, 일련의 데이터 구조와 함수의 집합이다.
    - 가장 변하지 않으며 외부로부터 영향을 받지 않는 영역이다.
- 유즈 케이스(Use Cases)
    - 애플리케이션의 특화된 업무 규칙을 포함한다.
    - 시스템의 모든 유즈 케이스를 캡슐화하고 구현한다.
    - 엔티티로 들어오고 나가는 데이터 흐름을 조정하고 조작한다.
- 인터페이스 어댑터(Interface Adapter)
    - 일련의 어댑터들로 구성한다.
    - 외부 인터페이스에서 들어오는 데이터를 유즈 케이스와 엔티티에서 처리하기 편한 방식으로 변환하며, 유즈 케이스와 엔티티에서 나가는 데이터를 외부 인터페이스에서 처리하기 편한 방식으로 변환한다. 컨트롤러, 프레젠터, 게이트웨이 등이 여기에 속한다.
- 프레임워크와 드라이버(Frameworks & Drivers)
    - 시스템의 핵심 업무와는 관련 없는 세부 사항이다.
    - 프레임워크나, 데이터베이스, 웹 서버 등이 여기에 해당한다.

여기서

이때 클린 아키텍처는 **경계**를 가장 중요시한다. 로버트 마틴은 경계에 대해 다음과 같이 설명한다.
> 소프트웨어 아키텍처는 선을 긋는 기술이며, 나는 이러한 선을 경계(boundary)라고 부른다.  
> 경계는 소프트웨어 요소를 서로 분리하고, 경계 한편에 있는 요소가 반대편에 있는 요소를 알지 못하도록 막는다. - 로버트 C. 마틴

화살표의 방향은 의존성을 뜻한다. 클린 아키텍처의 의존성은 밖에서 안으로 향하고, 바깥 원은 안쪽 원에 영향을 미치지 않는다. 경계의 바깥으로 갈수록 덜 중요하고 세부적인 영역으로 표현되며, 안으로 갈수록 고수준(좀더 추상화된 개념)으로 표현된다.

예를 들어보자.

A라는 앱의 개발자는 여러가지 요구사항을 받는다.
1. A의 핵심 기능은 유지하고 UI 와 DB 쪽만 바꿔주세요.  
2. A 앱을 웹으로 확장시켜주세요.  

만약 클린 아키텍처를 도입했다면, 단순하게 **인터페이스 어댑터 영역**과 **프레임워크와 드라이브 영역**만 수정하면 된다. 왜냐하면 핵심 비즈니스 로직은 변하지 않았기 때문이다. 이처럼 클린 아키텍처는 비즈니스 로직은 바꾸지 않으면서 언제든 DB와 프레임워크에 구애 받지 않고 교체할 수 있는 아키텍처인 셈이다.

로버트 C. 마틴의 클린 아키텍처는 다소 추상적이기 때문에 조금 더 깊게 들어가서 클린 아키텍처의 원칙들을 조금 더 구체적으로 만들어주는 **육각형 아키텍처**에 대해 살펴보자.

> 육각형 아키텍처(Hexagonal Architecture)  
> 육각형 아키텍처(Hexagonal Architecture), 또는 포트와 어댑터 아키텍처(Ports and Adapters Architecture)는 소프트웨어 아키텍처 중 하나로, 알리스테어 콕번에 의해 제안되었다.
> 이 아키텍처의 주요 목표는 응용 프로그램의 비즈니스 로직을 외부 세계로부터 격리시켜 유연하고 테스트하기 쉬운 구조를 만드는 것이다.
이를 위해 핵심 비즈니스 로직은 중앙의 도메인 영역에 위치하며, 입력과 출력을 처리하는 포트와 어댑터를 통해 외부와 소통한다.

![그림2.4](/pic/그림2.4.png)

육각형 안에는 도메인 엔티티와 이와 상호작용하는 유스케이스가 있다. 육각형에서 외부로 향하는 의존성이 없기 때문에 마틴이 클린 아키텍처에서 제시한 의존성 규칙이 그대로 적용된다는 점을 주목하자. 대신 모든 의존성은 **코어**를 향한다.