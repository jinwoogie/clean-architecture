# 만들면서 배우는 클린 아키텍처

### 1장. 계층형 아키텍처의 문제는 무엇일까?

일반적인 3계층 아키텍처는 <strong>웹 -> 도메인 -> 영속성</strong> 으로 구성되어 있다.  
웹 계층에서 요청을 받아 도메인 혹은 비즈니스 계층에 있는 서비스로 요청을 보낸다. 서비스에서는 필요한 비즈니스 로직을 수행하고, 도메인 엔티티의 현재 상태를 조회하거나 변경하기 위해 <strong>영속성</strong> 계층의 컴포넌트를 호출한다.  
잘 만들어진 계층형 아키텍처는 선택의 폭을 넓히고 변화하는 요구사항과 외부 요인에 빠르게 적응할 수 있게 해준다. 하지만 코드에 나쁜 습관들이 스며들기 쉽게 만들고 시간이 지날수록 소프트웨어를 점점 더 변경하기 어렵게 만드는 수많은 허점들을 노출한다. 그 이유는 다음과 같다.

1. 계층형 아키텍처는 데이터베이스 주도 설계를 유도한다.
2. 지름길을 택하기 쉬워진다.
3. 테스트하기 어려워진다.
4. 유스케이스를 숨긴다.
5. 동시 작업이 어려워진다.

앞서 말한 이유들로 인해 계층형 아키텍처는 개발자로 하여금 시간이 지날수록 유지보수하기 어렵게 만든다.



### 2장. 의존성 역전하기

> 단일 책임 원칙(Single Responsibility Principle, SRP)  
> 컴포넌트를 변경하는 이유는 오직 하나뿐이어야 한다.

만약 컴포넌트를 변경할 이유가 한 가지라면 우리가 어떤 다른 이유로 소프트웨어를 변경하더라도 이 컴포넌트에 대해서는 전혀 신경 쓸 필요가 없다. 소프트웨어가 변경되더라도 여전히 우리가 기대한 대로 동작할 것이기 때문이다.  
하지만 많은 코드는 SRP를 위반하기 때문에 시간이 갈수록 변경하기가 더 어려워지고 그로 인해 변경 비용도 증가한다. 시간이 갈수록 컴포넌트가 변경할 더 많은 이유가 쌓여간다. 이후에는 한 컴포넌트를 바꾸는 것이 다른 컴포넌트가 실패하는 원인으로 작용할 수 있다.

계층형 아키텍처에서 계층 간 의존성은 항상 아래 방향(계층)을 가리킨다. 그러므로 영속성 계층에 대한 도메인 계층의 의존성 때문에 영속성 계층을 변경할 때마다 잠재적으로 도메인 계층도 변경해야 한다. 그러나 도메인 코드는 애플리케이션에서 가장 핵심 부분이기 때문에 영속성 코드가 바뀐다고 해서 도메인 코드까지 바꾸는 건 바람직하지 않다. 이 의존성을 제거하기 위해 <strong>의존성 역전 원칙</strong>을 이용해보자.

> 의존성 역전 원칙(Dependency Inversion Principle, DIP)  
> 코드상의 어떤 의존성이든 그 방향을 바꿀 수(역전시킬 수) 있다.

참고로 의존성의 양쪽 코드를 모두 제어할 수 있을 때만 의존성을 역전시킬 수 있다.
도메인 코드와 영속성 코드 간의 의존성을 역전시켜서 영속성 코드가 도메인 코드에 의존하고, 도메인 코드를 '변경할 이유'의 개수를 줄여보자.

![그림1.2](/그림1.2.png)

엔티티는 도메인 객체를 표현하고 도메인 코드는 이 엔티티들의 상태를 변경하는 일을 중심으로 하기 때문에 먼저 엔티티를 도메인 계층으로 올린다.

이제 영속성 계층의 리포지토리가 도메인 계층에 있는 엔티티에 의존하기 때문에 두 계층 사이에 순환 의존성이 생긴다. 이제 DIP 를 적용할 수 있다. 도메인 계층에 리포지토리에 대한 인터페이스를 만들고, 실제 리포지토리는 영속성 계층에서 구현하게 하는 것이다. 결과는 다음 그림과 같다.

![그림2.2](/그림2.2.png)

이처럼 도메인 계층에 인터페이스를 도입함으로써 의존성을 역전시킬 수 있고, 그 덕분에 영속성 계층이 도메인 계층에 의존하게 되었다.
